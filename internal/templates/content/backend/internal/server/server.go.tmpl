// Package server handles the configuration of the HTTP server.
package server

import (
  "context"
{{if (eq .DB "sqlite")}}
  "database/sql"
{{end}}
  "fmt"
  "log/slog"
  "net"
  "net/http"
  "os"
  "sync"
  "time"

	"github.com/alexedwards/scs/v2"
  "github.com/lmittmann/tint"
  "github.com/spf13/viper"
{{if (eq .DB "sqlite")}}
  _ "modernc.org/sqlite"
{{else  if (eq .DB "postgres")}}
	"github.com/jackc/pgx/v5/pgxpool"
{{end}}
)

const unixSocketPath = "/var/run/{{.MainName}}/{{.MainName}}.sock"

type Application struct {
  srv *http.Server
  // ErrorLog logs server errors.
  ErrorLog *slog.Logger
  // InfoLog informative server logger.
  InfoLog *slog.Logger
  // config centrally manages env. variables.
  config *viper.Viper
	sessionManager *scs.SessionManager
  // db connection.
{{if (eq .DB "sqlite")}}
  db *sql.DB
{{else  if (eq .DB "postgres")}}
	db  *pgxpool.Pool
{{end}}
	serverAddr     string
	socket         net.Listener
}

func NewApplication(ctx context.Context, requiredEnvVariables []string) (*Application, error) {
	app := new(Application)

	app.config = viper.New()
	err := app.FetchConfigValues(requiredEnvVariables)
	if err != nil {
		return nil, err
	}

	environment, err := app.GetConfigValueString("ENVIRONMENT")
	if err != nil {
		return nil, fmt.Errorf("unable to get environment value: %w", err)
	}

	app.setupLoggers(environment)

	err = app.configureListener(environment)
	if err != nil {
		return nil, fmt.Errorf("unable to configure net.Listener: %w", err)
	}

	err = app.startDBConnection(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to start a db connection: %w", err)
	}

	app.sessionManager = scs.New()
	app.sessionManager.Lifetime = 15 * 24 * time.Hour
	app.sessionManager.IdleTimeout = 15 * 24 * time.Hour
	app.sessionManager.Cookie.SameSite = http.SameSiteStrictMode // prevent CSRF attacks.

	err = app.setupServerParameters(app.sessionManager)
	if err != nil {
		return nil, fmt.Errorf("unable to setup the server's parameters: %w", err)
	}

	return app, nil
}

{{if (eq .DB "sqlite")}}
func (app *Application) startDBConnection(ctx context.Context) error {
	sqliteDBPath, err := app.GetConfigValueString("SQLITE_PATH")
	if err != nil {
		return fmt.Errorf("unable to get SQLITE_PATH env. variable: %w", err)
	}

	app.db, err = sql.Open("sqlite", sqliteDBPath)
	if err != nil {
		return fmt.Errorf("unable to establish a connection with DB: %w", err)
	}

	if err := app.db.PingContext(ctx); err != nil {
		return fmt.Errorf("unable to ping db: %w", err)
	}

	app.InfoLog.Info("Successfully pinged sqlite3 db", slog.String("sqlite_file_path", sqliteDBPath))
	return nil
}
{{else  if (eq .DB "postgres")}}
func (app *Application) startDBConnection(ctx context.Context) error {
	dbConnString, err := app.GetConfigValueString("DB_CONN_STRING")
	if err != nil {
		return fmt.Errorf("unable to get DB_CONN_STRING env. variable: %w", err)
	}

	app.db, err = pgxpool.New(ctx, dbConnString)
	if err != nil {
		return fmt.Errorf("could not establish database connection pool: %w", err)
	}
	err = app.db.Ping(ctx)
	if err != nil {
		return fmt.Errorf("database is unreachable: %w", err)
	}

	app.InfoLog.Info("Successfully pinged postgres db")
  return nil
}
{{end}}

// StartServerWithGracefulShutdown starts a server and gracefully handles shutdowns.
// If the server receives a signal the backend knows that it should
// start the process of gracefully shutting down, i.e. closing DB connections and
// closing client connections.
func (app *Application) StartServerWithGracefulShutdown(ctx context.Context) error {
	serverErrCh := make(chan struct{})

	var wg sync.WaitGroup
	var serverErr error

	wg.Go(func() {
		app.InfoLog.Info("Starting {{.MainName}} server", slog.String("server_address", app.serverAddr))

		// Run server.
		if err := app.srv.Serve(app.socket); err != nil {
			// Error returned when server is closed, not actually an error, log to
			// info log.
			if err == http.ErrServerClosed {
				app.InfoLog.Info(err.Error())
			} else {
				// An actual error happened, log to error log.
				app.ErrorLog.Error("an error happened while executing LinstenAndServe()", slog.String("error_message", err.Error()))
				serverErr = err
			}
		}

		// Close the channel to signal all waiting goroutines that the server has stopped.
		close(serverErrCh)
	})

	wg.Go(func() {
		// Wait for either context cancellation or a server error.
		select {
		case <-ctx.Done():
		case <-serverErrCh:
		}

		shutdownCtx := context.Background()
		shutdownCtx, cancel := context.WithTimeout(shutdownCtx, 15*time.Second)
		defer cancel()
		// Received an interrupt signal, shutdown.
		if err := app.srv.Shutdown(shutdownCtx); err != nil {
			// Error from closing listeners, or context timeout.
			app.ErrorLog.Error("server is not shutting down", slog.String("error_message", err.Error()))
			// An error happened while gracefully shutting down, close abruptly.
			app.srv.Close()
		}
		if app.serverAddr == unixSocketPath {
			os.Remove(unixSocketPath)
		}
	})

	wg.Go(func() {
		// Wait for either context cancellation or a server error.
		select {
		case <-ctx.Done():
		case <-serverErrCh:
		}
		app.InfoLog.Info("closing db connection")
{{if (eq .DB "sqlite")}}
		err := app.db.Close()
		if err != nil {
			app.ErrorLog.Error("error while closing db connection", slog.String("error_message", err.Error()))
		}
{{else  if (eq .DB "postgres")}}
    app.db.Close()
{{end}}
		app.InfoLog.Info("successfully closed db connection")
	})

	// Wait on all goroutines performing asynchronous shutdowns before returning.
	wg.Wait()
	app.InfoLog.Info("server gracefully shut down")

	if serverErr != nil {
		return fmt.Errorf("server error: %w", serverErr)
	}

	return nil
}

func (app *Application) setupLoggers(environment string) {
	if environment != "prod" {
		app.InfoLog = slog.New(tint.NewHandler(os.Stdout, nil))
		app.ErrorLog = slog.New(tint.NewHandler(os.Stderr, nil))
	} else {
		app.InfoLog = slog.New(slog.NewJSONHandler(os.Stdout, nil))
		app.ErrorLog = slog.New(slog.NewJSONHandler(os.Stderr, nil))
	}

	app.InfoLog = app.InfoLog.With("environment", environment)
	app.ErrorLog = app.ErrorLog.With("environment", environment)
}

func (app *Application) setupServerParameters(sessionManager *scs.SessionManager) error {
	// http.Server can only handle loggers from the old log package.
	compatibleLogger := slog.NewLogLogger(slog.NewJSONHandler(os.Stderr, nil), slog.LevelError)

	endpoints, err := app.defineEndpoints(sessionManager)
	if err != nil {
		return fmt.Errorf("unable to define endpoints: %w", err)
	}

	app.srv = &http.Server{
		ErrorLog: compatibleLogger,
		Handler:  endpoints,
		// Time after which inactive keep-alive connections will be closed.
		IdleTimeout: time.Minute,
		// Max. time to read the header and body of a request in the server.
		ReadTimeout: 30 * time.Second,
		// Close connection if data is still being written after this time since
		// accepting the connection.
		WriteTimeout: 30 * time.Second,
	}

	return nil
}

func (app *Application) configureListener(environment string) error {
	if environment != "prod" {
		portValue, err := app.GetConfigValueString("PORT")
		if err != nil {
			return fmt.Errorf("unable to get port value: %w", err)
		}

		host := ""
		hostPort := net.JoinHostPort(host, portValue)

		app.socket, err = net.Listen("tcp", hostPort)
		if err != nil {
			return fmt.Errorf("unable to listen for TCP connections on host:port %s: %w", hostPort, err)
		}
		app.serverAddr = hostPort

	} else {
		app.serverAddr = unixSocketPath
		// Remove the socket file if it already exists to prevent
		// "address already in use" errors.
		err := os.RemoveAll(unixSocketPath)
		if err != nil {
			return fmt.Errorf("unable to remove socket at %s: %w", unixSocketPath, err)
		}
		// Create a Unix domain socket and listen for incoming connections.
		app.socket, err = net.Listen("unix", unixSocketPath)
		if err != nil {
			return fmt.Errorf("unable to create unix socket: %w", err)
		}
		// Socket is only accessible to `{{.MainName}}` service user and `www` service user (for
		// Caddy. All other users should not have access to the Unix socket.
		err = os.Chmod(unixSocketPath, 0o770)
		if err != nil {
			return fmt.Errorf("unable to change file permissions of socket %s: %w", unixSocketPath, err)
		}
	}
	return nil
}
